Floating bar
Ще разгледаме един вариант за кодиране на рационални числа в 32 бита, а именно:
най-старшият бит показва знака, аналогично на стандартните типове
следващите 5 бита са число, наречено bar position, или B
знаменателят е записан в най-младшите B бита
числителят е записан в останалите 26-B на брой бита
Ето няколко примерни рационални числа със своето кодиране (празните места са за яснота):
1/3: 0 00010 000000000000000000000001 11
9/8: 0 00100 0000000000000000001001 1000
-3/2: 1 00010 000000000000000000000011 10
0: 0 00001 0000000000000000000000000 1
1: 0 00001 0000000000000000000000001 1
-10: 1 00001 0000000000000000000001010 1
1/4000000: 0 10110 0001 1111010000100100000000
Уточнения:
числителят е винаги неотрицателен, а знаменателя строго положителен;
числителят и знаменателят винаги са взаимнопрости числа. Например 4/6 не се счита за валидна дроб, ами се опростява до 2/3 и това се кодира;
целите числа считаме за рационални със знаменател 1;
не разглеждаме числа, чиито опростени числител и знаменател не се побират в общо 26 бита.
Задачите:
Напишете следните функции, които работят с floating bar числа:
// Опростява и кодира дробта n/d в 32-битово цяло число
unsigned makeRat(int n, int d);

// Връща числителя на дадено рационално число, със знака на числото (т.е. отрицателно число за отрицателни дроби)
int getNumer(unsigned rat);

// Връща знаменателя на дадено рационално число, винаги положителен
int getDenom(unsigned rat);

// Изчисляват _точно_ и кодират съответно сумата/разликата/произведението/частното на дадени две рационални числа.
// Това означава, че използване на float и double в междинните изчисления е забранено (!)
unsigned ratAdd(unsigned r1, unsigned r2);
unsigned ratSub(unsigned r1, unsigned r2);
unsigned ratMul(unsigned r1, unsigned r2);
unsigned ratDiv(unsigned r1, unsigned r2);

// Връща реципрочното на дадено рационално число
unsigned ratRec(unsigned rat);
// Връща противоположното на дадено рационално число
unsigned ratNeg(unsigned rat);
// Връща абсолютната стойност на дадено рационално число
unsigned ratAbs(unsigned rat);

// Превръща рационално число в стандартно дробно число
float rat2float(unsigned rat);
Напишете в кратък коментар в кода по едно предимство/недостатък на това представяне. Дайте пример за число, което можем да представим точно по този начин, но не като стандартен float. Дайте пример и за обратното.
Упътване
Можете да използвате наготово следните функции:
// Връща най-големият общ делител на две неотрицателни числа
int gcd(int a, int b) {
    if (a < b) {
        return gcd(b, a);
    } else if (b != 0) {
        return gcd(b, a % b);
    } else {
        return a;
    }
}
// Връща броят битове, необходим за представянето на дадено положително число
int numBits(int n) {
    int res = 0;
    while (n != 0) {
        n >>= 1; ++res;
    }
    return res;
}
Бонус - имплицитен водещ бит на знаменателя
Аналогично на стандартния формат за дробни числа, тук знаем, че знаменателят е ненулево число с водещ бит единица. Тогава числото B може да съдържа броят останали битове от представянето му, и само те да участват в кодирането:
1/3 -> 0 00001 0000000000000000000000001 1
9/8 -> 0 00011 00000000000000000001001 000
42 -> 0 00000 00000000000000000000101010 (!)
Променете вашите функции така, че да работят с този усложнен формат. Напишете по едно предимство/недостатък на това усложнение.
Бонус - сравнение със fp32

Различните представяния на реални числа имат различни предимства и недостатъци. Напишете кратка функция която да сравни грешката при събиране на голямо количество реални числа представени по два различни начина (fp32 и floating bar)

// Изчислява сумата на даден масив от рационални числа по два начина: точно и след превръщането им във float.
// Отпечатайте двата резултата и ги сравнете - в кои случаи единият е верен и в кои случаи другият?
void compareSums(unsigned rats[1000000]);

Предаване на кода

За да може да проверим вашите работи, трябва да спазите следните правила:

Може да се качи само един файл (архив от позволените формати) който да съдържа всичките нужни файлове. Има лимит на размера на архива - целта е да не добавяте временните файлове от компилация.
Освен изходният код трябва да качите и проектен файл който описва как се компилира вашият код. Това е проектен файл от средата за разработка която ползвате или файл който може да бъде изпълнен от терминал и ще компилира изцяло вашият код.
Някъде в предадените файлове трябва да упоменете спецификите на системата която използвате за да компилирате кода си (операционна система, компилатор, версия, среда за разработка и версия ако има такава)
